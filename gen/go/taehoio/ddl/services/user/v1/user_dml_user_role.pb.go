// Code generated by protoc-gen-go-ddl. DO NOT EDIT.
// versions:
//  protoc-gen-go-ddl v0.0.1-alpha
//  protoc            (unknown)
// source: taehoio/ddl/services/user/v1/user.proto

package userddlv1

import (
	"database/sql"
	"strings"

	"github.com/xissy/kubeflake"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/timestamppb"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

//go:generate mockgen -package userddlv1 -self_package "github.com/taehoio/ddl/gen/go/taehoio/ddl/services/user/v1" -source ./user_dml_user_role.pb.go -destination ./user_dml_user_role_mock.pb.go -mock_names UserRoleRecorder=MockUserRoleRecorder "github.com/taehoio/ddl/gen/go/taehoio/ddl/services/user/v1" UserRoleRecorder

const (
	userRoleInsertStmt = `
		INSERT INTO user_role (
			id, created_at, updated_at, deleted_at, user_id, role
		) VALUES (
			?, ?, ?, ?, ?, ?
		)
	`

	userRoleUpdateStmt = `
		UPDATE user_role SET
			id = ?, created_at = ?, updated_at = ?, deleted_at = ?, user_id = ?, role = ?
		WHERE
			id = ?
	`
)

var (
	_ = timestamppb.Timestamp{}
	_ = wrapperspb.Int32Value{}
)

type UserRoleRecorder interface {
	Get(db *sql.DB, id uint64) (*UserRole, error)
	List(db *sql.DB, lastID *wrapperspb.UInt64Value, asc bool, limit int64) ([]*UserRole, error)
	FindByIDs(db *sql.DB, ids []uint64) ([]*UserRole, error)
	Save(db *sql.DB) error
	FindOneByUserId(db *sql.DB, userId interface{}) (*UserRole, error)
	FindByUserId(db *sql.DB, userId interface{}) ([]*UserRole, error)
}

func (m *UserRole) Get(db *sql.DB, id uint64) (*UserRole, error) {
	stmt, err := db.Prepare("SELECT * FROM user_role WHERE id = ?")
	if err != nil {
		return nil, err
	}
	defer stmt.Close()

	var mm UserRole

	var createdAt sql.NullTime
	var updatedAt sql.NullTime
	var deletedAt sql.NullTime

	if err = stmt.QueryRow(id).Scan(
		&mm.Id,
		&createdAt,
		&updatedAt,
		&deletedAt,
		&mm.UserId,
		&mm.Role,
	); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	if createdAt.Valid {
		mm.CreatedAt = timestamppb.New(createdAt.Time)
	}
	if updatedAt.Valid {
		mm.UpdatedAt = timestamppb.New(updatedAt.Time)
	}
	if deletedAt.Valid {
		mm.DeletedAt = timestamppb.New(deletedAt.Time)
	}

	return &mm, nil
}

func (m *UserRole) List(db *sql.DB, lastID *wrapperspb.UInt64Value, asc bool, limit int64) ([]*UserRole, error) {
	q := "SELECT * FROM user_role"
	if lastID != nil {
		if asc {
			q += " WHERE id > ?"
		} else {
			q += " WHERE id < ?"
		}
	}
	if asc {
		q += " ORDER BY id ASC"
	} else {
		q += " ORDER BY id DESC"
	}
	q += " LIMIT ?"

	stmt, err := db.Prepare(q)
	if err != nil {
		return nil, err
	}
	defer stmt.Close()

	var args []interface{}
	if lastID != nil {
		args = append(args, lastID.Value)
	}
	args = append(args, limit)

	rows, err := stmt.Query(args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var arr []*UserRole

	for rows.Next() {
		var mm UserRole

		var createdAt sql.NullTime
		var updatedAt sql.NullTime
		var deletedAt sql.NullTime

		if err = rows.Scan(
			&mm.Id,
			&createdAt,
			&updatedAt,
			&deletedAt,
			&mm.UserId,
			&mm.Role,
		); err != nil {
			return nil, err
		}

		if createdAt.Valid {
			mm.CreatedAt = timestamppb.New(createdAt.Time)
		}
		if updatedAt.Valid {
			mm.UpdatedAt = timestamppb.New(updatedAt.Time)
		}
		if deletedAt.Valid {
			mm.DeletedAt = timestamppb.New(deletedAt.Time)
		}

		arr = append(arr, &mm)
	}

	return arr, nil
}

func (m *UserRole) FindByIDs(db *sql.DB, ids []uint64) ([]*UserRole, error) {
	if len(ids) == 0 {
		return nil, nil
	}

	q := "SELECT * FROM user_role WHERE id IN ("
	for i := range ids {
		if i > 0 {
			q += ", "
		}
		q += "?"
	}
	q += ")"

	stmt, err := db.Prepare(q)
	if err != nil {
		return nil, err
	}
	defer stmt.Close()

	var args []interface{}
	for _, id := range ids {
		args = append(args, id)
	}

	rows, err := stmt.Query(args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var arr []*UserRole

	for rows.Next() {
		var mm UserRole

		var createdAt sql.NullTime
		var updatedAt sql.NullTime
		var deletedAt sql.NullTime

		if err = rows.Scan(
			&mm.Id,
			&createdAt,
			&updatedAt,
			&deletedAt,
			&mm.UserId,
			&mm.Role,
		); err != nil {
			return nil, err
		}

		if createdAt.Valid {
			mm.CreatedAt = timestamppb.New(createdAt.Time)
		}
		if updatedAt.Valid {
			mm.UpdatedAt = timestamppb.New(updatedAt.Time)
		}
		if deletedAt.Valid {
			mm.DeletedAt = timestamppb.New(deletedAt.Time)
		}

		arr = append(arr, &mm)
	}

	return arr, nil
}

func (m *UserRole) FindOneByUserId(db *sql.DB, userId interface{}) (*UserRole, error) {
	stmt, err := db.Prepare("SELECT * FROM user_role WHERE user_id=?")
	if err != nil {
		return nil, err
	}
	defer stmt.Close()

	var mm UserRole

	var createdAt sql.NullTime
	var updatedAt sql.NullTime
	var deletedAt sql.NullTime

	if err = stmt.QueryRow(userId).Scan(
		&mm.Id,
		&createdAt,
		&updatedAt,
		&deletedAt,
		&mm.UserId,
		&mm.Role,
	); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	if createdAt.Valid {
		mm.CreatedAt = timestamppb.New(createdAt.Time)
	}

	if updatedAt.Valid {
		mm.UpdatedAt = timestamppb.New(updatedAt.Time)
	}

	if deletedAt.Valid {
		mm.DeletedAt = timestamppb.New(deletedAt.Time)
	}

	return &mm, nil
}

func (m *UserRole) FindByUserId(db *sql.DB, userId interface{}) ([]*UserRole, error) {
	stmt, err := db.Prepare("SELECT * FROM user_role WHERE user_id=?")
	if err != nil {
		return nil, err
	}
	defer stmt.Close()

	rows, err := stmt.Query(userId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var arr []*UserRole

	for rows.Next() {
		var mm UserRole

		var createdAt sql.NullTime
		var updatedAt sql.NullTime
		var deletedAt sql.NullTime

		if err = rows.Scan(
			&mm.Id,
			&createdAt,
			&updatedAt,
			&deletedAt,
			&mm.UserId,
			&mm.Role,
		); err != nil {
			if err == sql.ErrNoRows {
				return nil, nil
			}
			return nil, err
		}

		if createdAt.Valid {
			mm.CreatedAt = timestamppb.New(createdAt.Time)
		}

		if updatedAt.Valid {
			mm.UpdatedAt = timestamppb.New(updatedAt.Time)
		}

		if deletedAt.Valid {
			mm.DeletedAt = timestamppb.New(deletedAt.Time)
		}

		arr = append(arr, &mm)
	}

	return arr, nil
}

func (m *UserRole) Save(db *sql.DB) error {
	if m.Id == 0 {
		m.Id = kubeflake.Must(kubeflake.New())
	}

	shouldInsert := true
	mm, err := m.Get(db, m.Id)
	if err != nil && err != sql.ErrNoRows {
		return err
	}
	if mm != nil {
		shouldInsert = false
	}

	if shouldInsert {
		if err := m.insert(db); err != nil {
			return err
		}
	} else {
		if err := m.update(db); err != nil {
			return err
		}
	}

	mm, err = m.Get(db, m.Id)
	if err != nil {
		return err
	}

	proto.Merge(m, mm)

	return nil
}

func (m *UserRole) insert(db *sql.DB) error {
	currentAt := timestamppb.Now()

	_, err := db.Exec(
		userRoleInsertStmt,
		m.Id,
		currentAt.AsTime(),
		currentAt.AsTime(),
		nil,
		m.UserId,
		m.Role,
	)
	if err != nil {
		if strings.HasPrefix(err.Error(), "Error 1062: Duplicate entry") {
			return ErrDuplicateEntry
		}
		return err
	}

	return nil
}

func (m *UserRole) update(db *sql.DB) error {
	currentAt := timestamppb.Now()

	_, err := db.Exec(
		userRoleUpdateStmt,
		m.Id,
		currentAt.AsTime(),
		currentAt.AsTime(),
		nil,
		m.UserId,
		m.Role,
		m.Id,
	)
	if err != nil {
		return err
	}

	return nil
}
